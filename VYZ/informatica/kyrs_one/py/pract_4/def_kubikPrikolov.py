from functools import lru_cache

# ЗАДАЧА 3 ПРАКТИКИ 4

# Входят данные формата 
# Х0
# 0Х

# Значит в поле 2на2 ты должен нарисовать (n=1)
# Х0 --
# 0X --
# -- Х0
# -- 0Х

# СМ ПРИМЕР НИЖЕ С МАШТАБОМ ДЛЯ ПОНИМАНИЯ, В МАСШАБЕ ВЫБИРАЕТСЯ ГДЕ РИСОВАТЬ
# А ГДЕ НЕ РИОВАТЬ НАЛОГИЧНО ДАННОЙ СТРУКТУРЕ С МАСШТАБОМ 1 ДАЛЕЕ Я ЕЕ СЧИТАЮ
# "БАЗОВОЙ" СТРУКТУРОЙ С МАСШТАБОМ 1

# ПРОШУ ЗАМЕТИТЬ ЧТО В "ОТРИСОВКУ" ПОПАДАЮТ ВСЕ СТРОКИ\ДАННЫЕ ПОЛУЧЕННЫЕ НА ВХОДЕ
# БЫЛО БЫ БОЛЬШЕ СТРОК ТО ЗА БАЗОВЫЙ СЕГМЕНТ ОТРИСОВКИ СЧИАТАЛИСЬ БЫ ВСЕ СТРОКИ :
# Х0 --
# 0X --
# XX -- 
# -- Х0
# -- 0Х
# -- XX
# X0 X0
# 0X 0X
# XX XX

# допом можно ввести n которое типа будет масштабом т е если n=2 то 
# Х0 -- X0 -- -- -- -- --
# 0X -- 0X -- -- -- -- --
# -- X0 -- X0 -- -- -- --
# -- 0X -- 0X -- -- -- --
# -- -- -- -- Х0 -- Х0 -- 
# -- -- -- -- 0Х -- 0X --
# -- -- -- -- -- Х0 -- X0
# -- -- -- -- -- 0Х -- 0X
# РАЗБЕРЕМ ПОДРОБНЕЕ :
# Х0 -- X0 -- & -- -- -- --             ТУТ РИСУЕМ  &      
# 0X -- 0X -- & -- -- -- --             СЕГМЕНТ МА- & ТУТ НИЧЕ                            ВХОДНЫЕ       
# -- X0 -- X0 & -- -- -- --             СШТАБОМ МЕ- & НЕ РИСУЕМ                            ДАННЫЕ:
# -- 0X -- 0X & -- -- -- --             НЬШЕ ТК X   & ТК ТУТ 0             X & 0            X0
# & & & & & & & & & & & & &   =======>  & & & & & & & & & & & & &  =====>  & & & =======>   0X
# -- -- -- -- & Х0 -- Х0 --              ТУТ НИЧЕ   & ТУТ РИСУЕМ           0 & X
# -- -- -- -- & 0Х -- 0X --              НЕ РИСУЕМ  & СЕГМЕНТ МА-              
# -- -- -- -- & -- Х0 -- X0              ТК ТУТ 0   & СШТАБОМ МЕ-              
# -- -- -- -- & -- 0Х -- 0X                         & НЬШЕ ТК X               
# И ТАК АНАЛОГИЧНО ДЛЯ ВСЕГО

# в этой ж папке прикреплю фотографии для наглядности

# Я ОЧЕНЬ ДОЛГО ДУМАЛ НАД СТРУКТУРОЙ РАБОТЫ ПРОГРАММЫ И УПАКОВКИ ДАННЫХ В ОДИН МАССИВ ГДЕ ПОРЯДКОВЫЙ
# НОМЕР ЭЛЕМЕНТА ЭТО НОМЕР СТРОКИ, ПРОСТО ВЗЯЛ ТАКИЕ ВЫХОДНЫЕ ДАННЫЕ ЗА ТО ЧТО Я ХОЧУ ПОЛУЧИТЬ ПОСЛЕ
# РАБОТЫ ФУНКЦИИ. ДУМАЛ Я ОЧЕНЬ ДОЛГО КАК И ЧТО СДЕЛАТЬ В ИТОГЕ ПРИШЕЛ К ВЫВОДУ ЧТО БУДУ ИСПОЛЬЗОВАТЬ 
# РЕКУРСИЮ С ЗАВЯЗКОЙ НА САМ МАСШТАБ
#  САМОЙ ЗАДАЧЕЙ ВООБЩЕ БЫЛО ПРОСТО ОТРИСОВАТЬ ВСЕ ЭТО В ОДНОМ ЕДИНСТВЕННОМ МАСШТАБЕ КОТОРЫЙ Я ВЗЯЛ ЗА
#  ЕДЕНИЧНЫЙ (n=1) И БЕЗ ПОДДЕРЖКИ НЕОГРАНИЧЕННОГО ЧИСЛА СТРОК И БЕЗ ПОДДЕРЖКИ НЕОГР ЧИСЛА СИМВОЛОВ В СТРОКЕ
#  НО Я РЕШИЛ ЧТО ГОРАЗДО ЛЕГЧЕ БУДЕТ СДЕЛАТЬ ВСЕ СРАЗУ А НЕ ПОТОМ ЛЕПИТЬ МУТАНТА ИЗ КУСКОВ
#  РЕШИЛ КРЧ СОЗДАТЬ СРАЗУ ВСЕ ЦЕЛЬНОЕ И ТИПА МОНОЛИТНОЕ
#  РАБОТАЛ Я ДОЛГО НУ КАК РАБОТАЛ СИДЕЛ В ЭКРАН ТУПИЛ ДУМАЛ КАК ЧЕ СДЕЛАТЬ ОЧЕНЬ ДОЛГО ДУМАЛ 
#  МНЕ ПРИШЛОСЬ ПРОДУМЫВАТЬ ЧЕ Я ХОЧУ И ЧТО СЧИТАТЬ КАКИМ МАСШТАБОМ, ВСЮ СТРУКТУРУ И АРХИТЕКТУРУ ПРОДУМЫВАТЬ
#  ЭТО БЫЛО ТЯЖЕЛО СЛОВНО СТРОИТЬ ДОМ С КРЫШЫ НО Я КОЕ КАК СПРАВИЛСЯ И ВСЕ ДАЖЕ ВРОДЕБЫ РАБОТАЕТ

# ТК Я РЕШИЛ ПРЕМЕНИТЬ ТЕХНОЛОГИЮ РЕКУРСИВНОСТИ МНЕ НУЖЕН УНИВЕРСАЛЬНЫЙ АЛГОРИТМ ДЛЯ ЛЮБОГО МАСШТАБА
# Я ПРИШЕЛ К ВЫВОДУ ЧТО МАСШТАБ 1 (n=1) БУДЕТ ТЕМ САМЫМ ЧТО ФУНКЦИЯ БУДЕТ ВОЗВРАЩАТЬ В КОНЕЧНОМ ИТОГЕ
# А ПОТОМ ИЗ ЭТОГО КАК КОНСТРУКТОР УЖЕ СОБЕРЕТСЯ ВСЕ ОСТАЛЬНОЕ ВЫШЕ МАСШТАБОМ
# РЕШИТЬ СДЕЛАТЬ ТАК С ПОЛНОГО НУЛЯ ИМЕЯ ЛИШЬ ОЖИДАЕМЫЕ ВХОДНЫЕ И НУЖНЫЕ ВЫХОДНЫЕ ДАННЫЕ БЫЛО ОЧЕНЬ ТЯЖЕЛО
# Я ТЕПЕРЬ ПОНИМАЮ ПОЧЕМУ В НОРМ КОМПАНИЯХ И КОМАНДАХ ЕСТЬ ОТЕЛЬНАЯ ПРОФЕССИЯ "АРХИТЕКТОР"...........

# в процессе написания кода я много принимал и от многово отказывался но ничего почти не удалял а просто каоментил
# но эти комментраии составляли большую часть монитора поэтому я их вынес вниз файла и
# дополнительной в файле с самой практикой 4 оставли то что оставил когда решил что там много 
# мусора в виде комментариев и ебанул все в мейн тест в корневаой папке чтобы там со всем разобраться 
# удалив эту мешанину из комментариев которая путала мои трудные мысли
# сейчас четко можно увидеть мое течение мыслей ну почти четко, как итоговая прога отличается от того 
# с чего я начинал, я придумывал концепции решал что и как что у меня будет тк единств ч у меня было это просто
# входные и выходные данные и доп задачей было еще сделать масштаб кучу строк и кучу символов в строке

# если совсем чето интересно то гляньте one.py или даже этот файл по истории коммитов там мб я чето и удалял

@lru_cache(None)
def kybikPrikolov(stroki,n):

    baseLines=stroki.split(",")
    if len(set(len(line) for line in baseLines)) > 1:
        print("введены неверные данные (длина строк не равна)")
        return 0
    #3 см низ файла просто эту тучу коментов вынес туда тк это исторические рудементы этого файла
    if n<1:
        n=1
        # return baseLines
    
    if n==1:
        retM=[""]*(len(baseLines)**(n+1))
        f=0
        for j in range(len(baseLines)):
            for k in baseLines[j]:      # X0X, 000
                if k=="X":
                    #   РИСУЕМ СЕГМЕНТ
                    i=f
                    for ik,i in zip(baseLines,range(f,len(baseLines)+f)):
                            retM[i]+=ik+" "
                if k=="0":
                    #  НЕ РИСУЕМ СЕГМЕНТ
                    for i in range(f,len(baseLines)+f):
                        retM[i]+="-"*len(baseLines[0])+" "
            f+=len(baseLines)
        return retM
    else:#              3**2*3
        retM=[""]*((len(baseLines)**2)*len(baseLines))
        # масштаб(n) больше базы
        # значит тупа конструируем масштабик из базы
        nowROW=0
        for j in range(len(baseLines)):
            
            for k in baseLines[j]:
                if k=="X":#1
                    # ЗАПОЛНЯЕМ СЕГМЕНТ НИЗШЕВЫМИ СЕГМЕНТАМИ ИЗ kybikPrikolov(stroki,n-1)
                    for ik,i in zip(kybikPrikolov(stroki,n-1),range(nowROW,(len(baseLines)**2)+nowROW)):
                        retM[i]+=ik+" "
                if k=="0":
                    strokNULL="".join(("0"*len(baseLines[0]))+"," for i in baseLines)
                    strokNULL=strokNULL[:-1]
                    # жестко хитрим
                    for ik,i in zip(kybikPrikolov(strokNULL,n-1),range(nowROW,(len(baseLines)**2)+nowROW)):
                        retM[i]+=ik+" "

            nowROW+=len(baseLines)**2 # мб тут надо +=len(baseLines)**(n+1) но кому не похуй
            # всеравно при масштабе 4 и больше все нахуй хуевится
            #  не буду я доводить до ума такие больше масштабы у меня сессию за это мне не закроют
            #  мир против программирования даже на факультете за 240б мешают прогать своими сессиями и физиками мне
        return retM

retm= kybikPrikolov("0X,X0,XX",2)
for i in range(len(retm)):
    print(retm[i])









    #1
    # есть идея тупо ебануть списочек с сегментами и где один там красить 1 0 1 0 1 0
                    # рисуем по строку : baseSIGMENTrow**(n+1)/(baseSIGMENTrow**(n+1)/baseSIGMENTrow**n) 
                    #                                2**1/(2**2)/2 = 2
                    #           СЕГМЕНТ ЭТО ОТРИСОВКА СТРОКИ ПО ТРЕБОВАНИЮ ДАННОЙ СТРОКИ В РАЗМЕЖОВКЕ
                    # Пример :
                    # дано :
                    # X0,0X,n=1
                    # получается :
                    # X0 --         ==> начало первого сегмента по требованию первой строки
                    # 0X --         ==> конец первого сегмента по требованию первой строки
                    # -- X0         ==> начало Второго сегмента по требованию Второй строки
                    # -- 0X         ==> конец ВТорого сегмента по требованию Второй строки
                    # по идее крч тут еще по столбец и рекурсией внутрь передать чтобы внутри сегмента все отрисовать
                    # и так каждый сегмент по этим двум циклам выше но я хз как упаковать данные
                    # //////////////////////////////////////////

    #3
        # if n in None or not isinstance(n, int):
    #     n=1

    #  16 : 16/2 = 2 -> мельчайший сегмент ; если строк 2(басе сигмент) и зум 3(n)
    #  басе сегмент**(зум+1)/(басе сегмент**(зум+1)/басе сегмент**зум) = мельчайший сегмент = басе сегмент
    #  2**(3+1)/(2**(3+1)/2**3) = 2
    #  16/(16/8)=2 = колво строк
    #  baseSIGMENTrow**(n+1)/(baseSIGMENTrow**(n+1)/baseSIGMENTrow**n)

    # сегмент зума
    # басе сегмент строк**(зум+1) = всего строк при зуме
    # басе сегмент строк**(зум+1)/басе сегмент строк*(зум-зум+1) = первый сегмент текущего зума
    # басе сегмент строк**(зум+1)/басе сегмент строк*(зум-зум+2) = второй сегмент текущего зума
    # 3**(3)/3*(1)=3
    #                                       и так пока зум-зум+i!=зум
    #                                       сегментов всегда столько сколько строк на вход поступило
