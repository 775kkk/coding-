def f(x1,c,max_):
    if x1>=13:
        return c%2==max_%2
    if c==max_:
        return 0
    if c%2!=max_%2:
        return f(x1+1,c+1,max_) or f(x1+3,c+1,max_)
    else:
        return f(x1+1,c+1,max_) or f(x1+3,c+1,max_) 
for s in range(1,23+1):
    for j in range(2,3):
        if f(s,0,j)==1:
            print(s,j)

# Два игрока, Петя и Ваня, играют в следующую игру.
# Перед игроками лежат две кучи камней. Игроки ходят по очереди,
# первый ход делает Петя. За один ход игрок может добавить в меньшую кучу
# один или три камня. Изменять количество камней в большей куче не разрешается.
# Игра завершается, когда количество камней в кучах становится равным.
# Победителем считается игрок, сделавший последний ход, то есть первым
# сравнявшим количество камней в двух кучах. Игроки играют рационально,
# т.е. без ошибок. В начальный момент в первой куче было 13 камней, а во второй
# Ѕ камней, 1 ≤ S ≤ 23? Укажите такое минимальное значение Ѕ,
# при котором Петя не может выиграть за один ход, но при любом ходе
# Пети Ваня может выиграть своим первым ходом

# хз как его кодом пользоваться вроде в есле надо ор на енд менять...
# а в цикле ниже вроде j - колво ходово, а третьий иф функции означает ход вани, тк он не чет всегда,
#  хз капец ваще какойто
        