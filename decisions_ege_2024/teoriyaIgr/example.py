from functools import lru_cache
@lru_cache(None)
def f(x):
    if x>=33:
        return 0
    t = [f(x+3),f(x*2)]
    n = [s for s in t if s<=0]
    if n:
        return -max(n)+1
    else:
        return -max(t)
for i in range(1,33):
    if f(i)==-1:
        print(i)

# another moment :
# Два игрока, Петя и Ваня, играют в следующую игру.
# Перед игроками лежат две кучи камней. Игроки ходят по очереди,
# первый ход делает Петя. За один ход игрок может добавить в меньшую кучу
# один или три камня. Изменять количество камней в большей куче не разрешается.
# Игра завершается, когда количество камней в кучах становится равным.
# Победителем считается игрок, сделавший последний ход, то есть первым
# сравнявшим количество камней в двух кучах. Игроки играют рационально,
# т.е. без ошибок. В начальный момент в первой куче было 13 камней, а во второй
# Ѕ камней, 1 ≤ S ≤ 23? Укажите такое минимальное значение Ѕ,
# при котором Петя не может выиграть за один ход, но при любом ходе
# Пети Ваня может выиграть своим первым ходом
        
        # ТУТ нету верхней границы! поэтому все несколько сложнее
@lru_cache(None)   
def fx(a,b):
    if a==b:
        return 0
    if a<b:
        if a+3==b:         #             если сделать тут так:
            t=[fx(a+3,b)]  #             t = [f(a+3,b),f(a+1,b)]
        elif a+1 ==b:      #             то он тут нах не дойдет до 
            t=[fx(a+1,b)]  #             a==b, тк в ситуациях 15 16
        else: t = [fx(a+3,b),fx(a+1,b)]# он еще будет считать fx(18,16)
    else:                  #             и так далее... ну пон тип бесконечно
        if b+3==a:
            t=[fx(a,b+3)]
        elif b+1 ==a:
            t=[fx(a,b+1)]
        else: t = [fx(a,b+3),fx(a,b+1)]
    n = [s for s in t if s<=0]
    if n:
        return -max(n)+1
    else:
        return -max(t)
for i in range(1,24):
    print(i, fx(13,i))
    