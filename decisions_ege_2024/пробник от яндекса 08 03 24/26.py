f=open("decisions_ege_2024/пробник от яндекса 08 03 24/26.txt")
n=int(f.readline())
a=[list(map(int,i[20:].split())) for i in f]
# print(a)
set1=[0]*10000
# время учитывать я никак не буду
# print(set1)
# print(a[9][0])
c=0
for i in range(len(a)):
    c+=1
    # x=a[i][0]
    set1[a[i][0]]+=1
    if c==3300:
        break # я заметил что в файле 3 дня и они все уже отсортированы по порядку времени,
#397й участник на протяжении всех трех дней делал большевсех
# c 1200 решенной задачи или около того участник 379 уже имел 13 решенных
# со временем его решенные задачи росли, никто не догонял и даже близко не был
# поэтому из-за неясности суждения о победителе в задачи делаю вывод
# что 379 участник в любом случае победил, какой бы отрезок времени не взяли, главное
# отрезок должен быть не менее чем в 1200 решенных задач
# еще дано число n, странно, зачем оно дано. Я бы понял зачем, если бы в файле временные промежутки 
# ограничивались колвом решенных задач, но это тоже не создавало бы проблем
    
#  в a=[list(map(int,i[20:].split())) for i in f] я случайно обрезал первую цифру
#  кода участника поставив i[21:]... поэтому мой ответ не верен
#  а время тут играет роль только в предподчтении победителя в случае
# если у двух людей одинаковое колво намеров, предпочтение отдается тому кто быстрее решил эти 15

# продинамив с помощью конструкции 14-15 я бы нашел ответ 100%

# думаю можно было бы учесть простым условием типа
    # if mxzad>current:
        # mxzad=current
    # и таким образом соблелся бы порядок с выбором победителя
# это более хороший способ отобрать участника, тк я шагал перебирая c в 100 
# задач, а если бы один решил всего бы на секунду раньше чем другой?
print(max(set1))
print(set1.index(max(set1)))
# 29
# 397